"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[4758],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),h=o,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},19004:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],s={id:"create-a-simple-squid",title:"Create a simple squid",description:"This page is about taking the Squid template and customizing it to create a simple project"},c="Create a simple Squid",l={unversionedId:"tutorial/create-a-simple-squid",id:"tutorial/create-a-simple-squid",title:"Create a simple squid",description:"This page is about taking the Squid template and customizing it to create a simple project",source:"@site/docs/tutorial/create-a-simple-squid.md",sourceDirName:"tutorial",slug:"/tutorial/create-a-simple-squid",permalink:"/docs/tutorial/create-a-simple-squid",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial/create-a-simple-squid.md",tags:[],version:"current",frontMatter:{id:"create-a-simple-squid",title:"Create a simple squid",description:"This page is about taking the Squid template and customizing it to create a simple project"},sidebar:"tutorialSidebar",previous:{title:"Tutorial",permalink:"/docs/tutorial/"},next:{title:"Create an EVM-processing Squid",permalink:"/docs/tutorial/create-an-evm-processing-squid"}},d={},u=[{value:"Objective",id:"objective",level:2},{value:"Pre-requisites",id:"pre-requisites",level:2},{value:"Fork the template",id:"fork-the-template",level:2},{value:"Run the project",id:"run-the-project",level:3},{value:"Install new dependencies",id:"install-new-dependencies",level:2},{value:"Define Entity Schema",id:"define-entity-schema",level:2},{value:"Generate TypeScript interfaces",id:"generate-typescript-interfaces",level:2},{value:"Chain exploration",id:"chain-exploration",level:3},{value:"Types bundle",id:"types-bundle",level:3},{value:"Events wrappers generation",id:"events-wrappers-generation",level:3},{value:"Define and bind Event Handlers",id:"define-and-bind-event-handlers",level:2},{value:"Apply changes to the Database",id:"apply-changes-to-the-database",level:2},{value:"Remove default migration",id:"remove-default-migration",level:3},{value:"Launch the project",id:"launch-the-project",level:2},{value:"Credits",id:"credits",level:2}],p={toc:u};function h(e){var t=e.components,s=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"create-a-simple-squid"},"Create a simple Squid"),(0,a.kt)("h2",{id:"objective"},"Objective"),(0,a.kt)("p",null,"This tutorial will take the Squid template and go through all the necessary steps to customize the project, in order to interact with a different Squid Archive, synchronized with a different blockchain, and process data from Events different from the ones in the template."),(0,a.kt)("p",null,"The business logic to process such Events is very basic, and that is on purpose since the purpose of the Tutorial is to show a simple case, highlighting the changes a developer would typically apply to the template, removing unnecessary complexity."),(0,a.kt)("p",null,"The blockchain used in this example will be the ",(0,a.kt)("a",{parentName:"p",href:"https://crust.network"},"Crust storage network")," and the final objective will be to observe which files have been added and deleted from the chain, as well as groups joined and storage orders placed by a determined account."),(0,a.kt)("h2",{id:"pre-requisites"},"Pre-requisites"),(0,a.kt)("p",null,"The minimum requirements to follow this tutorial are the basic knowledge of software development, such as handling a Git repository, a correctly set up ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/development-environment-set-up"},"Development Environment"),", basic command line knowledge and the concepts explained in this documentation."),(0,a.kt)("h2",{id:"fork-the-template"},"Fork the template"),(0,a.kt)("p",null,"The first thing to do, although it might sound trivial to GitHub experts, is to fork the repository into your own GitHub account, by visiting the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-template"},"repository page")," and clicking the Fork button:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"How to fork a repository on GitHub",src:n(36844).Z,width:"1894",height:"258"})),(0,a.kt)("p",null,"Next, clone the created repository (be careful of changing ",(0,a.kt)("inlineCode",{parentName:"p"},"<account>")," with your own account)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git clone git@github.com:<account>/squid-template.git\n")),(0,a.kt)("p",null,"For reference on the complete work, you can find the entire project ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-crust-example"},"here"),"."),(0,a.kt)("h3",{id:"run-the-project"},"Run the project"),(0,a.kt)("p",null,"Next, just follow the ",(0,a.kt)("a",{parentName:"p",href:"/docs/quickstart"},"Quickstart")," to get the project up and running, here's a list of commands to run in quick succession:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm ci\nnpm run build\ndocker compose up -d\nnpx sqd db create\nnpx sqd db migrate\nnode -r dotenv/config lib/processor.js\n# open a separate terminal for this next command\nnpx squid-graphql-server\n")),(0,a.kt)("p",null,"Bear in mind this is not strictly ",(0,a.kt)("strong",{parentName:"p"},"necessary"),", but it is always useful to check that everything is in order."),(0,a.kt)("p",null,'{% hint style="info" %}\nThese commands are supposed to be run the first time, right after cloning the template.'),(0,a.kt)("p",null,"Some, like ",(0,a.kt)("inlineCode",{parentName:"p"},"npx sqd db create"),",  may throw an error, because the database had already been previously created. In this case just run ",(0,a.kt)("inlineCode",{parentName:"p"},"npx sqd db drop")," and run ",(0,a.kt)("inlineCode",{parentName:"p"},"npx sqd db create")," again.\n{% endhint %}"),(0,a.kt)("p",null,"If you are not interested, you could at least get the Postgres container running with ",(0,a.kt)("inlineCode",{parentName:"p"},"docker compose up -d"),"."),(0,a.kt)("h2",{id:"install-new-dependencies"},"Install new dependencies"),(0,a.kt)("p",null,"For this specific project, we will need to install a new dependency since the ",(0,a.kt)("a",{parentName:"p",href:"/docs/faq/where-do-i-get-a-type-bundle-for-my-chain"},"type definitions")," for the Crust blockchain are implemented in the ",(0,a.kt)("inlineCode",{parentName:"p"},"@crustio/types-definition")," package."),(0,a.kt)("p",null,"Navigate to the repository's root window in a command line console and install it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"npm i @crustio/type-definitions\n")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.gyazo.com/e135e7aa19b6217d1b701df8f51a91d2.gif",alt:"Install Crust type definition"})),(0,a.kt)("h2",{id:"define-entity-schema"},"Define Entity Schema"),(0,a.kt)("p",null,"The next thing to do, in order to customize the project for our own purpose, is to make changes to the schema and define the Entities we want to keep track of."),(0,a.kt)("p",null,"Because we said we want to track"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"files added and deleted from the chain"),(0,a.kt)("li",{parentName:"ul"},"groups joined by a certain account"),(0,a.kt)("li",{parentName:"ul"},"storage orders placed by a certain account")),(0,a.kt)("p",null,"We are going to make these changes to our ",(0,a.kt)("inlineCode",{parentName:"p"},"schema.graphql"),":"),(0,a.kt)("p",null,'{% code title="schema.graphql" %}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'type Account @entity {\n  id: ID! #Account address\n  workReports: [WorkReport] @derivedFrom(field: "account")\n  joinGroups: [JoinGroup] @derivedFrom(field: "member")\n  storageOrders: [StorageOrder] @derivedFrom (field: "account")\n}\n\ntype WorkReport @entity {\n  id: ID! #event id\n  account: Account!\n  addedFiles: [[String]]\n  deletedFiles: [[String]]\n  extrinsicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n\ntype JoinGroup @entity {\n  id: ID!\n  member: Account!\n  owner: String!\n  extrinsicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n\ntype StorageOrder @entity {\n  id: ID!\n  account: Account!\n  fileCid: String!\n  extrinsicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n')),(0,a.kt)("p",null,"{% endcode %}"),(0,a.kt)("p",null,"It's worth noticing that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Account")," entity is almost completely derived and it is there to tie the other three entities together, since Groups are joined by an Account, Storage Orders are placed by an Account and Work Reports, show files added and changed by, you guessed it, an Account!"),(0,a.kt)("p",null,"This all requires some implicit knowledge of the blockchain itself (",(0,a.kt)("a",{parentName:"p",href:"/docs/faq/how-do-i-know-which-events-and-extrinsics-i-need-for-the-handlers"},"here's a tip")," on how to obtain this information)."),(0,a.kt)("p",null,"To finalize this step, it is necessary to run the ",(0,a.kt)("inlineCode",{parentName:"p"},"codegen")," tool:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx sqd codegen\n")),(0,a.kt)("p",null,"This will automatically generate TypeScript Entity classes for our schema definition, which can be found under the ",(0,a.kt)("inlineCode",{parentName:"p"},"src/model/generated")," folder in the project."),(0,a.kt)("h2",{id:"generate-typescript-interfaces"},"Generate TypeScript interfaces"),(0,a.kt)("p",null,"The process to generate wrappers around TypeScript wrappers around Events and Extrinsics has a ",(0,a.kt)("a",{parentName:"p",href:"/docs/key-concepts/typegen"},"dedicated page")," to explain it and a quick ",(0,a.kt)("a",{parentName:"p",href:"/docs/recipes/running-a-squid/generate-typescript-definitions"},"Recipe")," to guide you through it, so it is advised to consult them for more information."),(0,a.kt)("h3",{id:"chain-exploration"},"Chain exploration"),(0,a.kt)("p",null,"What matters in the context of this tutorial, is to pay attention to the ",(0,a.kt)("inlineCode",{parentName:"p"},"chain"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"archive")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"out")," parameters, which refer to the related WebSocket address of the Crust blockchain, the Squid Archive synchronized with it (this is optional, but helps speed up the process) and the output file simply contains the chain name as a good naming convention (this is useful in case of multiple chains handled in the same project or folder)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx squid-substrate-metadata-explorer \\\n        --chain wss://rpc-crust-mainnet.decoo.io \\\n        --archive https://crust.indexer.gc.subsquid.io/v4/graphql \\\n        --out crustVersions.json\n")),(0,a.kt)("p",null,"The output is visible in the ",(0,a.kt)("inlineCode",{parentName:"p"},"crustVersions.json")," file, and although the ",(0,a.kt)("inlineCode",{parentName:"p"},"metadata")," field is intelligible, it's worth noting that (at the time of creating of this tutorial) there are 13 different ",(0,a.kt)("inlineCode",{parentName:"p"},"versions"),", meaning the Runtime has changed 13 times."),(0,a.kt)("p",null,"It remains to be seen if this had any impacts on the definitions of the Events we are interested in."),(0,a.kt)("h3",{id:"types-bundle"},"Types bundle"),(0,a.kt)("p",null,"One peculiar thing about the Crust chain and this example is that, at the moment of writing of this guide, its types have not been integrated into Squid's library."),(0,a.kt)("p",null,"This gives us a good opportunity to follow ",(0,a.kt)("a",{parentName:"p",href:"/docs/faq/where-do-i-get-a-type-bundle-for-my-chain"},"this mini-guide")," and create an example, extracting a types bundle from crust's own library, to Subsquid required format."),(0,a.kt)("p",null,'{% hint style="info" %}\n',(0,a.kt)("strong",{parentName:"p"},"Update"),': the "crust" types bundle has been added to the list of built-ins, but for learning purposes, it\'s still useful to see how to create and use a types bundle JSON file.\n{% endhint %}'),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Here is the end result, copy it and paste it into a file named ",(0,a.kt)("code",null,"crustTypesBundle.json")),(0,a.kt)("p",null,'{% code title="crustTypesBundle.json" %}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "types": {},\n    "typesAlias": {},\n    "versions": [\n      {\n        "minmax": [\n          null,\n          null\n        ],\n        "types": {\n          "MerchantLedger": { "reward": "Balance", "collateral": "Balance" },\n          "FileInfoV2": {\n              "file_size": "u64",\n              "spower": "u64",\n              "expired_at": "BlockNumber",\n              "calculated_at": "BlockNumber",\n              "amount": "Compact<Balance>",\n              "prepaid": "Compact<Balance>",\n              "reported_replica_count": "u32",\n              "remaining_paid_count": "u32",\n              "replicas": "BTreeMap<AccountId, Replica<AccountId>>"\n          },\n          "UsedInfo": {\n            "used_size": "u64",\n            "reported_group_count": "u32",\n            "groups": "BTreeMap<SworkerAnchor, bool>"\n          },\n          "AccountInfo": "AccountInfoWithProviders",\n          "Address": "AccountId",\n          "AddressInfo": "Vec<u8>",\n          "LookupSource": "AccountId",\n          "EraBenefits": {\n            "total_fee_reduction_quota": "Compact<Balance>",\n            "total_market_active_funds": "Compact<Balance>",\n            "used_fee_reduction_quota": "Compact<Balance>",\n            "active_era": "Compact<EraIndex>"\n          },\n          "FundsType": {\n            "_enum": [\n              "SWORK",\n              "MARKET"\n            ]\n          },\n          "FundsUnlockChunk": {\n            "value": "Compact<Balance>",\n            "era": "Compact<EraIndex>"\n          },\n          "MarketBenefit": {\n            "total_funds": "Compact<Balance>",\n            "active_funds": "Compact<Balance>",\n            "used_fee_reduction_quota": "Compact<Balance>",\n            "file_reward": "Compact<Balance>",\n            "refreshed_at": "Compact<EraIndex>",\n            "unlocking_funds": "Vec<FundsUnlockChunk<Balance>>"\n          },\n          "SworkBenefit": {\n            "total_funds": "Compact<Balance>",\n            "active_funds": "Compact<Balance>",\n            "total_fee_reduction_count": "u32",\n            "used_fee_reduction_count": "u32",\n            "refreshed_at": "Compact<EraIndex>",\n            "unlocking_funds": "Vec<FundsUnlockChunk<Balance>>"\n          },\n          "BridgeChainId": "u8",\n          "ChainId": "u8",\n          "ResourceId": "H256",\n          "DepositNonce": "u64",\n          "ProposalStatus": {\n            "_enum": [\n              "Initiated",\n              "Approved",\n              "Rejected"\n            ]\n          },\n          "ProposalVotes": {\n            "votes_for": "Vec<AccountId>",\n            "votes_against": "Vec<AccountId>",\n            "status": "ProposalStatus",\n            "expiry": "BlockNumber"\n          },\n          "Erc721Token": {\n            "id": "TokenId",\n            "metadata": "Vec<u8>"\n          },\n          "TokenId": "U256",\n          "ETHAddress": "Vec<u8>",\n          "EthereumTxHash": "H256",\n          "Lock": {\n            "total": "Compact<Balance>",\n            "last_unlock_at": "BlockNumber",\n            "lock_type": "LockType"\n          },\n          "LockType": {\n            "delay": "BlockNumber",\n            "lock_period": "u32"\n          },\n          "FileInfo": {\n            "file_size": "u64",\n            "spower": "u64",\n            "expired_at": "BlockNumber",\n            "calculated_at": "BlockNumber",\n            "amount": "Compact<Balance>",\n            "prepaid": "Compact<Balance>",\n            "reported_replica_count": "u32",\n            "replicas": "Vec<Replica<AccountId>>"\n          },\n          "Replica": {\n            "who": "AccountId",\n            "valid_at": "BlockNumber",\n            "anchor": "SworkerAnchor",\n            "is_reported": "bool",\n            "created_at": "Option<BlockNumber>"\n          },\n          "Guarantee": {\n            "targets": "Vec<IndividualExposure<AccountId, Balance>>",\n            "total": "Compact<Balance>",\n            "submitted_in": "EraIndex",\n            "suppressed": "bool"\n          },\n          "ValidatorPrefs": {\n            "guarantee_fee": "Compact<Perbill>"\n          },\n          "Group": {\n            "members": "BTreeSet<AccountId>",\n            "allowlist": "BTreeSet<AccountId>"\n          },\n          "IASSig": "Vec<u8>",\n          "Identity": {\n            "anchor": "SworkerAnchor",\n            "punishment_deadline": "u64",\n            "group": "Option<AccountId>"\n          },\n          "ISVBody": "Vec<u8>",\n          "MerkleRoot": "Vec<u8>",\n          "ReportSlot": "u64",\n          "PKInfo": {\n            "code": "SworkerCode",\n            "anchor": "Option<SworkerAnchor>"\n          },\n          "SworkerAnchor": "Vec<u8>",\n          "SworkerCert": "Vec<u8>",\n          "SworkerCode": "Vec<u8>",\n          "SworkerPubKey": "Vec<u8>",\n          "SworkerSignature": "Vec<u8>",\n          "WorkReport": {\n            "report_slot": "u64",\n            "spower": "u64",\n            "free": "u64",\n            "reported_files_size": "u64",\n            "reported_srd_root": "MerkleRoot",\n            "reported_files_root": "MerkleRoot"\n          }\n        }\n      }\n    ]\n  }\n')),(0,a.kt)("p",null,"{% endcode %}")),(0,a.kt)("h3",{id:"events-wrappers-generation"},"Events wrappers generation"),(0,a.kt)("p",null,"Next, we need to make a few changes in the ",(0,a.kt)("inlineCode",{parentName:"p"},"typegen.json")," configuration file, to adapt it to our purposes. We want to specify the same JSON file used as output in the previous command (in this case, ",(0,a.kt)("inlineCode",{parentName:"p"},"crustVersions.json"),"), then we need to specify the events that we are interested in, for this project."),(0,a.kt)("p",null,"Similar to what's been said in the previous chapter, this requires knowledge of the blockchain itself and some research might be required, but in the case of this example, the events are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"WorksReportSuccess")," from the ",(0,a.kt)("inlineCode",{parentName:"li"},"swork")," pallet"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"JoinGroupSuccess")," from the same pallet"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"FileSuccess")," from the market pallet")),(0,a.kt)("p",null,'{% code title="typegen.json" %}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "outDir": "src/types",\n  "chainVersions": "crustVersions.json",\n  "typesBundle": "crustTypesBundle.json",\n  "events": [\n    "swork.WorksReportSuccess",\n    "swork.JoinGroupSuccess",\n    "market.FileSuccess"\n  ],\n  "calls": []\n}\n')),(0,a.kt)("p",null,"{% endcode %}"),(0,a.kt)("p",null,"And finally, run the command to generate type-safe TypeScript wrappers around the metadata"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx squid-substrate-typegen typegen.json\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"The end result is in the ",(0,a.kt)("code",null,"src/types/events.ts")," file (because we only defined Events in our ",(0,a.kt)("code",null,"typegen.json"),") and should look something like this."),(0,a.kt)("p",null,'{% code title="events.ts" %}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import assert from 'assert'\nimport {EventContext, Result} from './support'\n\nexport class MarketFileSuccessEvent {\n  constructor(private ctx: EventContext) {\n    assert(this.ctx.event.name === 'market.FileSuccess')\n  }\n\n  /**\n   *  Place a storage order success.\n   *  The first item is the account who places the storage order.\n   *  The second item is the cid of the file.\n   */\n  get isLatest(): boolean {\n    return this.ctx._chain.getEventHash('market.FileSuccess') === '1a9528ba42fbec479c5a2ecdb509dab8c0ec5ddad8673e9644881405cc5b2548'\n  }\n\n  /**\n   *  Place a storage order success.\n   *  The first item is the account who places the storage order.\n   *  The second item is the cid of the file.\n   */\n  get asLatest(): [Uint8Array, Uint8Array] {\n    assert(this.isLatest)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n}\n\nexport class SworkJoinGroupSuccessEvent {\n  constructor(private ctx: EventContext) {\n    assert(this.ctx.event.name === 'swork.JoinGroupSuccess')\n  }\n\n  /**\n   *  Join the group success.\n   *  The first item is the member's account.\n   *  The second item is the group owner's account.\n   */\n  get isLatest(): boolean {\n    return this.ctx._chain.getEventHash('swork.JoinGroupSuccess') === '84a7eea101cadd963f8546bf8d9902de6418d1692a799fcbd8dc2b2ae2e5f947'\n  }\n\n  /**\n   *  Join the group success.\n   *  The first item is the member's account.\n   *  The second item is the group owner's account.\n   */\n  get asLatest(): [Uint8Array, Uint8Array] {\n    assert(this.isLatest)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n}\n\nexport class SworkWorksReportSuccessEvent {\n  constructor(private ctx: EventContext) {\n    assert(this.ctx.event.name === 'swork.WorksReportSuccess')\n  }\n\n  /**\n   *  Send the work report success.\n   *  The first item is the account who send the work report\n   *  The second item is the pub key of the sWorker.\n   */\n  get isLatest(): boolean {\n    return this.ctx._chain.getEventHash('swork.WorksReportSuccess') === '15de934ea25c85a846abb0c440c91b6dd207f2f512a0529b611dcd2e796b2319'\n  }\n\n  /**\n   *  Send the work report success.\n   *  The first item is the account who send the work report\n   *  The second item is the pub key of the sWorker.\n   */\n  get asLatest(): [Uint8Array, Uint8Array] {\n    assert(this.isLatest)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n}\n")),(0,a.kt)("p",null,"{% endcode %}")),(0,a.kt)("h2",{id:"define-and-bind-event-handlers"},"Define and bind Event Handlers"),(0,a.kt)("p",null,"After having obtained wrappers for Events and the metadata changes across different Runtime versions, it's finally time to define Handlers for these Events and attach them to our ",(0,a.kt)("a",{parentName:"p",href:"/docs/key-concepts/processor"},"Processor"),", and this is done in the ",(0,a.kt)("inlineCode",{parentName:"p"},"src/processor.ts")," file in the project folder."),(0,a.kt)("p",null,"We will end up replacing the code in this file almost entirely, leaving only a few useful pieces, but we are going to take a step-by-step approach, showing where essential changes have to be made, but the final result will be visible at the end of this section."),(0,a.kt)("p",null,"First of all, we need to import the generated Entity model classes, in order to be able to use them in our code. And then, we need the type definitions of Crust events, so that they can be used to wrap them. Let's replace previous models and types import at the top of our file with these two lines:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import  {Account, WorkReport, JoinGroup, StorageOrder} from './model/generated'\nimport { MarketFileSuccessEvent, SworkJoinGroupSuccessEvent, SworkWorksReportSuccessEvent } from './types/events'\n")),(0,a.kt)("p",null,"And add the Crust types definition as well:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as crustTypes from "@crustio/type-definitions";\n')),(0,a.kt)("p",null,"Then, we need to customize the processor, by giving it the right name, connecting it to the right Squid Archive and setting the correct types. This is done by substituting with the following code the top part of the file, that looks similar to it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const processor = new SubstrateProcessor('crust_example')\nprocessor.setDataSource({\n    archive: 'https://crust.indexer.gc.subsquid.io/v4/graphql',\n    chain: 'wss://rpc-crust-mainnet.decoo.io'\n});\nprocessor.setBlockRange({from: 583000}); // this is the starting block for exploring the chain, please don't mind it.\nprocessor.setTypesBundle(crustTypes);\n")),(0,a.kt)("p",null,"Next, because the added and deleted files are matrices, we are going to declare a function to handle that, for our own convenience. Simply add this code to the ",(0,a.kt)("inlineCode",{parentName:"p"},"src/processor.ts")," file, anywhere."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function stringifyArray(list: any[]): any[] {\n  let listStr : any[] = [];\n  list = list[0]\n  for (let vec of list){\n    for (let i = 0; i < vec.length; i++){\n      vec[i] = String(vec[i]);\n    }\n    listStr.push(vec);\n  }\n  return listStr\n}\n")),(0,a.kt)("p",null,"Now, we are going to take a different approach from the template and define event handlers as functions, and then add bind them to the processor via the ",(0,a.kt)("inlineCode",{parentName:"p"},"processor.addEventHandler()")," function call."),(0,a.kt)("p",null,"Here are the declarations for the Event handler functions, same as above, add this code somewhere in the file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'async function joinGroupSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new SworkJoinGroupSuccessEvent(ctx);\n  const memberId = ss58.codec("crust").encode(event.asV1[0]);\n  const account = await getOrCreate(ctx.store, Account, memberId);\n  const joinGroup = new JoinGroup();\n\n  joinGroup.id = ctx.event.id;\n  joinGroup.member = account;\n  joinGroup.owner = ss58.codec("crust").encode(event.asV1[1]);\n  joinGroup.blockHash = ctx.block.hash;\n  joinGroup.blockNum = ctx.block.height;\n  joinGroup.createdAt = new Date(ctx.block.timestamp);\n  joinGroup.extrinsicId = ctx.extrinsic?.id;\n\n  await ctx.store.save(account);\n  await ctx.store.save(joinGroup);\n}\n\nasync function fileSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new MarketFileSuccessEvent(ctx);\n  const accountId = ss58.codec("crust").encode(event.asV1[0]);\n  const account = await getOrCreate(ctx.store, Account, accountId);\n  const storageOrder = new StorageOrder();\n\n  storageOrder.id = ctx.event.id;\n  storageOrder.account = account;\n  storageOrder.fileCid = toHex(event.asV1[1]);\n  console.log("event fileCID", storageOrder.fileCid);\n  console.log("raw fileCID", String(ctx.event.params[1].value));\n  storageOrder.blockHash = ctx.block.hash;\n  storageOrder.blockNum = ctx.block.height;\n  storageOrder.createdAt = new Date(ctx.block.timestamp);\n  storageOrder.extrinsicId = ctx.extrinsic?.id;\n\n  await ctx.store.save(account);\n  await ctx.store.save(storageOrder);\n}\n\nasync function workReportSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new SworkWorksReportSuccessEvent(ctx);\n  const accountId = ss58.codec("crust").encode(event.asV1[0]);\n  const accountPr = getOrCreate(ctx.store, Account, accountId);\n  const addedFilesObjPr = ctx.extrinsic?.args.find(\n    (arg) => arg.name === "addedFiles"\n  );\n  const deletedFilesObjPr = ctx.extrinsic?.args.find(\n    (arg) => arg.name === "deletedFiles"\n  );\n  const [account, addFObj, delFObj] = await Promise.all([\n    accountPr,\n    addedFilesObjPr,\n    deletedFilesObjPr,\n  ]);\n\n  const workReport = new WorkReport();\n\n  workReport.addedFiles = stringifyArray(Array(addFObj?.value));\n  workReport.deletedFiles = stringifyArray(Array(delFObj?.value));\n  if (workReport.addedFiles.length > 0 || workReport.deletedFiles.length > 0) {\n    workReport.account = account;\n\n    workReport.id = ctx.event.id;\n    workReport.blockHash = ctx.block.hash;\n    workReport.blockNum = ctx.block.height;\n    workReport.createdAt = new Date(ctx.block.timestamp);\n    workReport.extrinsicId = ctx.extrinsic?.id;\n\n    await ctx.store.save(account);\n    await ctx.store.save(workReport);\n  }\n}\n')),(0,a.kt)("p",null,"Lastly, as mentioned earlier, we are going to get rid of the previous event handler, by replacing the code responsible for tying an arrow function to the processor, with our own, newly defined functions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"processor.addEventHandler('market.FileSuccess', fileSuccess);\nprocessor.addEventHandler('swork.JoinGroupSuccess', joinGroupSuccess);\nprocessor.addEventHandler('swork.WorksReportSuccess', workReportSuccess);\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Here is the end result, in case you missed something"),(0,a.kt)("p",null,'{% code title="processor.ts" %}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ss58 from "@subsquid/ss58";\nimport {\n  SubstrateProcessor,\n  EventHandlerContext,\n  Store,\n  toHex,\n} from "@subsquid/substrate-processor";\nimport {\n  Account,\n  WorkReport,\n  JoinGroup,\n  StorageOrder,\n} from "./model/generated";\nimport * as crustTypes from "@crustio/type-definitions";\nimport {\n  MarketFileSuccessEvent,\n  SworkJoinGroupSuccessEvent,\n  SworkWorksReportSuccessEvent,\n} from "./types/events";\n\nconst processor = new SubstrateProcessor("crust_example");\nprocessor.setDataSource({\n  archive: "https://crust.indexer.gc.subsquid.io/v4/graphql",\n  chain: "wss://rpc-crust-mainnet.decoo.io",\n});\nprocessor.setBlockRange({ from: 583000 });\nprocessor.setTypesBundle(crustTypes);\nprocessor.addEventHandler("market.FileSuccess", fileSuccess);\nprocessor.addEventHandler("swork.JoinGroupSuccess", joinGroupSuccess);\nprocessor.addEventHandler("swork.WorksReportSuccess", workReportSuccess);\n\nprocessor.run();\n\nfunction stringifyArray(list: any[]): any[] {\n  let listStr: any[] = [];\n  list = list[0];\n  for (let vec of list) {\n    for (let i = 0; i < vec.length; i++) {\n      vec[i] = String(vec[i]);\n    }\n    listStr.push(vec);\n  }\n  return listStr;\n}\n\nasync function joinGroupSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new SworkJoinGroupSuccessEvent(ctx);\n  const memberId = ss58.codec("crust").encode(event.asV1[0]);\n  const account = await getOrCreate(ctx.store, Account, memberId);\n  const joinGroup = new JoinGroup();\n\n  joinGroup.id = ctx.event.id;\n  joinGroup.member = account;\n  joinGroup.owner = ss58.codec("crust").encode(event.asV1[1]);\n  joinGroup.blockHash = ctx.block.hash;\n  joinGroup.blockNum = ctx.block.height;\n  joinGroup.createdAt = new Date(ctx.block.timestamp);\n  joinGroup.extrinsicId = ctx.extrinsic?.id;\n\n  await ctx.store.save(account);\n  await ctx.store.save(joinGroup);\n}\n\nasync function fileSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new MarketFileSuccessEvent(ctx);\n  const accountId = ss58.codec("crust").encode(event.asV1[0]);\n  const account = await getOrCreate(ctx.store, Account, accountId);\n  const storageOrder = new StorageOrder();\n\n  storageOrder.id = ctx.event.id;\n  storageOrder.account = account;\n  storageOrder.fileCid = toHex(event.asV1[1]);\n  console.log("event fileCID", storageOrder.fileCid);\n  console.log("raw fileCID", String(ctx.event.params[1].value));\n  storageOrder.blockHash = ctx.block.hash;\n  storageOrder.blockNum = ctx.block.height;\n  storageOrder.createdAt = new Date(ctx.block.timestamp);\n  storageOrder.extrinsicId = ctx.extrinsic?.id;\n\n  await ctx.store.save(account);\n  await ctx.store.save(storageOrder);\n}\n\nasync function workReportSuccess(ctx: EventHandlerContext): Promise<void> {\n  let event = new SworkWorksReportSuccessEvent(ctx);\n  const accountId = ss58.codec("crust").encode(event.asV1[0]);\n  const accountPr = getOrCreate(ctx.store, Account, accountId);\n  const addedFilesObjPr = ctx.extrinsic?.args.find(\n    (arg) => arg.name === "addedFiles"\n  );\n  const deletedFilesObjPr = ctx.extrinsic?.args.find(\n    (arg) => arg.name === "deletedFiles"\n  );\n  const [account, addFObj, delFObj] = await Promise.all([\n    accountPr,\n    addedFilesObjPr,\n    deletedFilesObjPr,\n  ]);\n\n  const workReport = new WorkReport();\n\n  workReport.addedFiles = stringifyArray(Array(addFObj?.value));\n  workReport.deletedFiles = stringifyArray(Array(delFObj?.value));\n  if (workReport.addedFiles.length > 0 || workReport.deletedFiles.length > 0) {\n    workReport.account = account;\n\n    workReport.id = ctx.event.id;\n    workReport.blockHash = ctx.block.hash;\n    workReport.blockNum = ctx.block.height;\n    workReport.createdAt = new Date(ctx.block.timestamp);\n    workReport.extrinsicId = ctx.extrinsic?.id;\n\n    await ctx.store.save(account);\n    await ctx.store.save(workReport);\n  }\n}\n\nasync function getOrCreate<T extends { id: string }>(\n  store: Store,\n  entityConstructor: EntityConstructor<T>,\n  id: string\n): Promise<T> {\n  let e = await store.get<T>(entityConstructor, {\n    where: { id },\n  });\n\n  if (e == null) {\n    e = new entityConstructor();\n    e.id = id;\n  }\n\n  return e;\n}\n\ntype EntityConstructor<T> = {\n  new (...args: any[]): T;\n};\n\n')),(0,a.kt)("p",null,"{% endcode %}")),(0,a.kt)("p",null,"A repository with the entire project is also available on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-crust-example"},"GitHub"),". If you like it, please leave a \u2b50"),(0,a.kt)("h2",{id:"apply-changes-to-the-database"},"Apply changes to the Database"),(0,a.kt)("p",null,"Squid project automatically manages the database connection and schema, via an ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping"},"ORM abstraction"),". As such, we need to use the provided automated tools to manage the database schema and migrations."),(0,a.kt)("h3",{id:"remove-default-migration"},"Remove default migration"),(0,a.kt)("p",null,"First, we need to get rid of the template's default migration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rm -rf db/migrations/*.js\n")),(0,a.kt)("p",null,"Then, make sure the Postgres docker container is running, in order to have a database to connect to, and run the following commands:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx sqd db drop\nnpx sqd db create\nnpx sqd db create-migration Init\nnpx sqd db migrate\n")),(0,a.kt)("p",null,"These will, in order:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"drop the current database",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If you did not ",(0,a.kt)("a",{parentName:"li",href:"/docs/tutorial/create-a-simple-squid#undefined"},"Run the project"),", this is not necessary"))),(0,a.kt)("li",{parentName:"ol"},"create a new database"),(0,a.kt)("li",{parentName:"ol"},"create the initial migration, by looking up the schema we defined in the previous chapter"),(0,a.kt)("li",{parentName:"ol"},"apply the migration")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.gyazo.com/8a9ed2b334f6cece50dee6f6c87e18d1.gif",alt:"Drop the database, re-create it, generate a migration and apply it"})),(0,a.kt)("h2",{id:"launch-the-project"},"Launch the project"),(0,a.kt)("p",null,"It's finally time to run the project. First of all, let's build the code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"npm run build\n")),(0,a.kt)("p",null,"And then launch the processor (this will block the current terminal)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"node -r dotenv/config lib/processor.js\n")),(0,a.kt)("p",null,"Launch the GraphQL server (in a separate command line console window)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"npx squid-graphql-server\n")),(0,a.kt)("p",null,"And see the results for ourselves the result of our hard work, by visiting the ",(0,a.kt)("inlineCode",{parentName:"p"},"localhost:4350/graphql")," URL in a browser and accessing the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphiql"},"GraphiQl")," console."),(0,a.kt)("p",null,"From this window, we can perform queries such as this one, to find which files have been added or deleted by an account:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"query AccountFiles{\n  accountById(id: <accountID>) {\n    workReports {\n      addedFiles\n      deletedFiles\n    }\n  }\n}\n")),(0,a.kt)("p",null,"It is advisable to search for an Account first and grab its ID."),(0,a.kt)("h2",{id:"credits"},"Credits"),(0,a.kt)("p",null,"This sample project is actually a real integration, developed by our very own ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ma-shulgin"},"Mikhail Shulgin"),". Credits for building it and helping with the guide go to him."))}h.isMDXComponent=!0},36844:function(e,t,n){t.Z=n.p+"assets/images/Screenshot-2022-02-02-111440-9f6e5c06848a0c57235ca9d820cedbc3.png"}}]);