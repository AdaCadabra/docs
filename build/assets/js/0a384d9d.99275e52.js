"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[4902],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=d(n),f=r,h=u["".concat(c,".").concat(f)]||u[f]||p[f]||s;return n?a.createElement(h,o(o({ref:t},l),{},{components:n})):a.createElement(h,o({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var d=2;d<s;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},14943:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return p}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),o=["components"],i={description:"Squid Typegen is a code generation tool for creating Typescript types for substrate Events, Extrinsics, Storage Items (for Substrate) and EVM logs."},c="Typegen",d={unversionedId:"key-concepts/typegen",id:"key-concepts/typegen",title:"Typegen",description:"Squid Typegen is a code generation tool for creating Typescript types for substrate Events, Extrinsics, Storage Items (for Substrate) and EVM logs.",source:"@site/docs/key-concepts/typegen.md",sourceDirName:"key-concepts",slug:"/key-concepts/typegen",permalink:"/docs/key-concepts/typegen",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/key-concepts/typegen.md",tags:[],version:"current",frontMatter:{description:"Squid Typegen is a code generation tool for creating Typescript types for substrate Events, Extrinsics, Storage Items (for Substrate) and EVM logs."},sidebar:"tutorialSidebar",previous:{title:"Substrate",permalink:"/docs/key-concepts/substrate"},next:{title:"SubstrateEvent",permalink:"/docs/mappings/substrateevent"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Substrate entities",id:"substrate-entities",level:3},{value:"EVM logs",id:"evm-logs",level:3},{value:"Blockchain metadata",id:"blockchain-metadata",level:2},{value:"TypeScript class wrappers",id:"typescript-class-wrappers",level:2},{value:"EVM Typegen",id:"evm-typegen",level:2},{value:"What&#39;s next?",id:"whats-next",level:2}],u={toc:p};function f(e){var t=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"typegen"},"Typegen"),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("h3",{id:"substrate-entities"},"Substrate entities"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#events"},"Event"),", ",(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#extrinsics"},"call"),", and ",(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#storage"},"Storage")," data are ingested as raw untyped JSON by the Processor. Not only is it unclear what the exact structure of a particular event or call is but, rather frequently, it can change over time."),(0,s.kt)("p",null,"Runtime upgrades may change the event data and even the event logic altogether. Fortunately, Squid has got you covered with first-class support for runtime upgrades. This comes in very handy when expressing business logic, mapping Events, Extrinsics, and Storage items with database Entities defined in the GraphQL schema."),(0,s.kt)("p",null,'Having Class wrappers around them makes it much easier to develop Event or Extrinsic Handlers, as well as pre- or post-block "hooks" and manage multiple metadata versions of a blockchain.'),(0,s.kt)("p",null,"Subsquid SDK comes with a CLI tool called ",(0,s.kt)("inlineCode",{parentName:"p"},"substrate metadata explorer")," which makes it easy to keep track of all runtime upgrades within a certain blockchain. This can then be provided to a different CLI tool called ",(0,s.kt)("inlineCode",{parentName:"p"},"typegen"),", to generate type-safe, spec version-aware wrappers around events and calls."),(0,s.kt)("p",null,"In the next section we'll be taking the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-template"},"squid template")," as an example."),(0,s.kt)("h3",{id:"evm-logs"},"EVM logs"),(0,s.kt)("p",null,"The Ethereum Virtual Machine smart contract is bytecode deployed on an EVM-capable blockchain. There could be several functions in a contract. An ",(0,s.kt)("em",{parentName:"p"},"Application Binary Interface")," is the interface between two program modules, one of which is often at the level of machine code. The interface is the de facto method for encoding/decoding data into/out of the machine code."),(0,s.kt)("p",null,"An ABI is necessary so that you can specify which function in the contract to invoke, as well as get a guarantee that the function will return data in the format you are expecting."),(0,s.kt)("p",null,"Subsquid has developed a CLI tool that is able to inspect the ABI in JSON format, parse it and create TypeScript interfaces and mappings to decode functions and data, as specified in the ABI itself."),(0,s.kt)("p",null,"Similarly to Substrate entities, having Interfaces for data and mappings for function decoding, speeds up the development of EVM log handler functions, creating standards for passing data around."),(0,s.kt)("h2",{id:"blockchain-metadata"},"Blockchain metadata"),(0,s.kt)("p",null,"The template was designed to explore the Kusama blockchain, specifically processing the ",(0,s.kt)("inlineCode",{parentName:"p"},"'balance.Transfer'")," event."),(0,s.kt)("p",null,"In order to generate wrapper classes, the first thing to do is to explore the entire history of the blockchain and extract its metadata. The ",(0,s.kt)("inlineCode",{parentName:"p"},"squid-substrate-metadata-explorer")," command (for more information on how to run it, head over to this ",(0,s.kt)("a",{parentName:"p",href:"/docs/recipes/running-a-squid/generate-typescript-definitions"},"Guide"),") will do the chain exploration and write it to a file. It will look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "blockNumber": 0,\n    "blockHash": "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",\n    "specVersion": 1020,\n    "metadata": "0x6d65746109701853797374656d011853797374656d34304163..."\n  },\n  // ...\n]\n')),(0,s.kt)("p",null,"Where the ",(0,s.kt)("inlineCode",{parentName:"p"},"metadata")," field is cut here, and the rest of the file is omitted for brevity, but there are multiple objects such as this one in this relatively large file. The point is that for every available ",(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#runtime"},"Runtime")," version of the blockchain, some metadata is available to be decoded and explored, and this metadata contains the necessary information to process its Events, Extrinsics, and Storage items."),(0,s.kt)("h2",{id:"typescript-class-wrappers"},"TypeScript class wrappers"),(0,s.kt)("p",null,"This file is then used by the ",(0,s.kt)("inlineCode",{parentName:"p"},"typegen")," command (again, look at the ",(0,s.kt)("a",{parentName:"p",href:"/docs/recipes/running-a-squid/generate-typescript-definitions"},"Guide")," for how to configure and run it) to decode and interpret the metadata, and then uses that to generate this TypeScript class:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export class BalancesTransferEvent {\n  constructor(private ctx: EventContext) {\n    assert(this.ctx.event.name === 'balances.Transfer')\n  }\n\n  /**\n   *  Transfer succeeded (from, to, value, fees).\n   */\n  get isV1020(): boolean {\n    return this.ctx._chain.getEventHash('balances.Transfer') === 'e1ceec345fa4674275d2608b64d810ecec8e9c26719985db4998568cfcafa72b'\n  }\n\n  /**\n   *  Transfer succeeded (from, to, value, fees).\n   */\n  get asV1020(): [Uint8Array, Uint8Array, bigint, bigint] {\n    assert(this.isV1020)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n\n  /**\n   *  Transfer succeeded (from, to, value).\n   */\n  get isV1050(): boolean {\n    return this.ctx._chain.getEventHash('balances.Transfer') === '2082574713e816229f596f97b58d3debbdea4b002607df469a619e037cc11120'\n  }\n\n  /**\n   *  Transfer succeeded (from, to, value).\n   */\n  get asV1050(): [Uint8Array, Uint8Array, bigint] {\n    assert(this.isV1050)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n\n  /**\n   * Transfer succeeded.\n   */\n  get isLatest(): boolean {\n    return this.ctx._chain.getEventHash('balances.Transfer') === '68dcb27fbf3d9279c1115ef6dd9d30a3852b23d8e91c1881acd12563a212512d'\n  }\n\n  /**\n   * Transfer succeeded.\n   */\n  get asLatest(): {from: v9130.AccountId32, to: v9130.AccountId32, amount: bigint} {\n    assert(this.isLatest)\n    return this.ctx._chain.decodeEvent(this.ctx.event)\n  }\n}\n")),(0,s.kt)("p",null,"This manages different runtime versions, including the starting hash for each and instructions for how to process (decode) the event itself."),(0,s.kt)("p",null,"All of this is better explained in the section dedicated to the ",(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/processor"},"Processor and Event mapping"),", but, given the class definition for a ",(0,s.kt)("inlineCode",{parentName:"p"},"BalanceTransferEvent"),", such a class can be used to handle events such as this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"processor.addEventHandler('balances.Transfer', async ctx => {\n    let transfer = getTransferEvent(ctx)\n    // ...\n})\n\n// ...\n\nfunction getTransferEvent(ctx: EventHandlerContext): TransferEvent {\n    let event = new BalancesTransferEvent(ctx)\n    if (event.isV1020) {\n        let [from, to, amount] = event.asV1020\n        return {from, to, amount}\n    } else if (event.isV1050) {\n        let [from, to, amount] = event.asV1050\n        return {from, to, amount}\n    } else {\n        return event.asLatest\n    }\n}\n")),(0,s.kt)("p",null,"Where, upon processing an event, its metadata version is checked, and the metadata is extracted accordingly, making things a lot easier."),(0,s.kt)("h2",{id:"evm-typegen"},"EVM Typegen"),(0,s.kt)("p",null,"Subsquid provides a tool called ",(0,s.kt)("inlineCode",{parentName:"p"},"squid-evm-typegen")," that accepts a JSON file, with an ABI definition as an input, and will generate a TypeScript file, containing Interfaces and decoding mappings as an output."),(0,s.kt)("p",null,"In the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-evm-template"},"squid-evm-template")," repository you'll find a JSON file containing ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-evm-template/blob/master/src/abi/ERC721.json"},"the ERC721 ABI")," and right next to it, the TypeScript file generated by such tool. Let's dissect and explain what it contains:"),(0,s.kt)("p",null,'{% code title="erc721.ts" %}'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'import * as ethers from "ethers";\n\nexport const abi = new ethers.utils.Interface(getJsonAbi());\n')),(0,s.kt)("p",null,"{% endcode %}"),(0,s.kt)("p",null,"These first two lines import and instantiate a programmatic interface for the ABI."),(0,s.kt)("p",null,"Then, a series of data interfaces are declared. These are the inputs and outputs of the functions declared in the ABI."),(0,s.kt)("p",null,'{% code title="erc721.ts" %}'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface ApprovalAddressAddressUint256Event {\n  owner: string;\n  approved: string;\n  tokenId: ethers.BigNumber;\n}\n\nexport interface ApprovalForAllAddressAddressBoolEvent {\n  owner: string;\n  operator: string;\n  approved: boolean;\n}\n\nexport interface TransferAddressAddressUint256Event {\n  from: string;\n  to: string;\n  tokenId: ethers.BigNumber;\n}\n\nexport interface EvmEvent {\n  data: string;\n  topics: string[];\n}\n")),(0,s.kt)("p",null,"{% endcode %}"),(0,s.kt)("p",null,"Below them, you'll find a dictionary that maps the signature of a function to its ",(0,s.kt)("inlineCode",{parentName:"p"},"topic")," and a method to decode it."),(0,s.kt)("p",null,'{% code title="erc721.ts" %}'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'export const events = {\n  "Approval(address,address,uint256)":  {\n    topic: abi.getEventTopic("Approval(address,address,uint256)"),\n    decode(data: EvmEvent): ApprovalAddressAddressUint256Event {\n      const result = abi.decodeEventLog(\n        abi.getEvent("Approval(address,address,uint256)"),\n        data.data || "",\n        data.topics\n      );\n      return  {\n        owner: result[0],\n        approved: result[1],\n        tokenId: result[2],\n      }\n    }\n  }\n  ,\n  "ApprovalForAll(address,address,bool)":  {\n    topic: abi.getEventTopic("ApprovalForAll(address,address,bool)"),\n    decode(data: EvmEvent): ApprovalForAllAddressAddressBoolEvent {\n      const result = abi.decodeEventLog(\n        abi.getEvent("ApprovalForAll(address,address,bool)"),\n        data.data || "",\n        data.topics\n      );\n      return  {\n        owner: result[0],\n        operator: result[1],\n        approved: result[2],\n      }\n    }\n  }\n  ,\n  "Transfer(address,address,uint256)":  {\n    topic: abi.getEventTopic("Transfer(address,address,uint256)"),\n    decode(data: EvmEvent): TransferAddressAddressUint256Event {\n      const result = abi.decodeEventLog(\n        abi.getEvent("Transfer(address,address,uint256)"),\n        data.data || "",\n        data.topics\n      );\n      return  {\n        from: result[0],\n        to: result[1],\n        tokenId: result[2],\n      }\n    }\n  }\n  ,\n}\n')),(0,s.kt)("p",null,"{% endcode %}"),(0,s.kt)("p",null,"At the bottom of the file, there will always be an auxiliary function that returns the ABI in a raw JSON format (not reported here, for brevity)."),(0,s.kt)("h2",{id:"whats-next"},"What's next?"),(0,s.kt)("p",null,"Head over to the ",(0,s.kt)("a",{parentName:"p",href:"/docs/key-concepts/processor"},"Processor")," page, for more information on how processing Events impacts database Entities."))}f.isMDXComponent=!0}}]);