"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[8009],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},55351:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),s=["components"],o={description:"The schema will help create database entities, as well as TypeScript classes wrapping them, and will be exposed to API clients by the GraphQL server."},l="Define a Squid Schema",c={unversionedId:"recipes/running-a-squid/define-a-squid-schema",id:"recipes/running-a-squid/define-a-squid-schema",title:"Define a Squid Schema",description:"The schema will help create database entities, as well as TypeScript classes wrapping them, and will be exposed to API clients by the GraphQL server.",source:"@site/docs/recipes/running-a-squid/define-a-squid-schema.md",sourceDirName:"recipes/running-a-squid",slug:"/recipes/running-a-squid/define-a-squid-schema",permalink:"/docs/recipes/running-a-squid/define-a-squid-schema",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/recipes/running-a-squid/define-a-squid-schema.md",tags:[],version:"current",frontMatter:{description:"The schema will help create database entities, as well as TypeScript classes wrapping them, and will be exposed to API clients by the GraphQL server."},sidebar:"tutorialSidebar",previous:{title:"Building with Docker",permalink:"/docs/recipes/running-a-squid/building-with-docker"},next:{title:"Generate type-safe interfaces",permalink:"/docs/recipes/running-a-squid/generate-typescript-definitions"}},p={},d=[{value:"Overview",id:"overview",level:2},{value:"Define the schema",id:"define-the-schema",level:2},{value:"Generate entity classes",id:"generate-entity-classes",level:2},{value:"Generated models",id:"generated-models",level:3}],u={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"define-a-squid-schema"},"Define a Squid Schema"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"In order to build powerful APIs on top of blockchain data, it is very important to have the right Entities to capture and describe transformed data."),(0,i.kt)("p",null,"Subsquid SDK helps developers by allowing them to define their entities in a dialect of the GraphQL schema definition language enriched with the additional directives and built-in primitive types. The input schema is then passed as input to the ",(0,i.kt)("inlineCode",{parentName:"p"},"codegen")," CLI tool to generate the entity classes for the database and the final GraphQL schema for the API server."),(0,i.kt)("p",null,"As far as what Entities to define and how they are tied to blockchain Events, Extrinsics, and block information, this needs affinity and knowledge of the blockchain itself, so for this guide, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/subsquid/squid-template"},"squid template")," is going to be taken as an example."),(0,i.kt)("h2",{id:"define-the-schema"},"Define the schema"),(0,i.kt)("p",null,"In this example, the entities we are interested are ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"HistoricalBalance")," which leads to the following schema:"),(0,i.kt)("p",null,'{% code title="schema.graphql" %}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'type Account @entity {\n  "Account address"\n  id: ID!\n  balance: BigInt!\n  historicalBalances: [HistoricalBalance!] @derivedFrom(field: "account")\n}\n\ntype HistoricalBalance @entity {\n  id: ID!\n  account: Account!\n  balance: BigInt!\n  date: DateTime!\n}\n')),(0,i.kt)("p",null,"{% endcode %}"),(0,i.kt)("p",null,"It's worth noting that the example explores the Kusama blockchain and it is configured to process the ",(0,i.kt)("inlineCode",{parentName:"p"},"balance.Transfer")," event, so these two entities make perfect sense."),(0,i.kt)("h2",{id:"generate-entity-classes"},"Generate entity classes"),(0,i.kt)("p",null,"The process to generate entity classes from the schema is simple enough, thanks to the Squid SDK ",(0,i.kt)("inlineCode",{parentName:"p"},"sqd codegen")," tool. Simply running the following command in a terminal window from the source folder of the project will start the process:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sqd codegen\n")),(0,i.kt)("p",null,"The command will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read the ",(0,i.kt)("inlineCode",{parentName:"li"},"schema.graphql")," file and parse it"),(0,i.kt)("li",{parentName:"ul"},"Create one model file in ",(0,i.kt)("inlineCode",{parentName:"li"},"src/model/generated")," for each entity encountered")),(0,i.kt)("p",null,'{% hint style="info" %}\nIt is worth stressing that database migrations have to be executed every time a change is done to the schema, in order for the processor to work correctly).'),(0,i.kt)("p",null,"Migration files are JavaScript files, but should not be modified or executed, the ",(0,i.kt)("inlineCode",{parentName:"p"},"sqd db migrate")," command handles that\n{% endhint %}"),(0,i.kt)("h3",{id:"generated-models"},"Generated models"),(0,i.kt)("p",null,"Here's a look at the generated TypeScript classes:"),(0,i.kt)("p",null,'{% code title="account.model.ts" %}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import {Entity as Entity_, Column as Column_, PrimaryColumn as PrimaryColumn_, OneToMany as OneToMany_} from "typeorm"\nimport * as marshal from "./marshal"\nimport {HistoricalBalance} from "./historicalBalance.model"\n\n@Entity_()\nexport class Account {\n  constructor(props?: Partial<Account>) {\n    Object.assign(this, props)\n  }\n\n  /**\n   * Account address\n   */\n  @PrimaryColumn_()\n  id!: string\n\n  @Column_("numeric", {transformer: marshal.bigintTransformer, nullable: false})\n  balance!: bigint\n\n  @OneToMany_(() => HistoricalBalance, e => e.account)\n  historicalBalances!: HistoricalBalance[]\n}\n')),(0,i.kt)("p",null,"{% endcode %}"),(0,i.kt)("p",null,'{% code title="historicalBalance.model.ts" %}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import {Entity as Entity_, Column as Column_, PrimaryColumn as PrimaryColumn_, ManyToOne as ManyToOne_, Index as Index_} from "typeorm"\nimport * as marshal from "./marshal"\nimport {Account} from "./account.model"\n\n@Entity_()\nexport class HistoricalBalance {\n  constructor(props?: Partial<HistoricalBalance>) {\n    Object.assign(this, props)\n  }\n\n  @PrimaryColumn_()\n  id!: string\n\n  @Index_()\n  @ManyToOne_(() => Account, {nullable: false})\n  account!: Account\n\n  @Column_("numeric", {transformer: marshal.bigintTransformer, nullable: false})\n  balance!: bigint\n\n  @Column_("timestamp with time zone", {nullable: false})\n  date!: Date\n}\n')),(0,i.kt)("p",null,"{% endcode %}"),(0,i.kt)("p",null,"As previously mentioned, these classes map to the tables in the database, in a classic ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping"},"ORM fashion"),"."))}m.isMDXComponent=!0}}]);