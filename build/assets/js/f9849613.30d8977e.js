"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[1834],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),f=a,m=u["".concat(s,".").concat(f)]||u[f]||d[f]||i;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},99157:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return d}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),o=["components"],c={},s="BigInt fields",l={unversionedId:"reference/openreader-schema/bigint-fields",id:"reference/openreader-schema/bigint-fields",title:"BigInt fields",description:"GraphQL objects types have names and fields, but at the end of the day, these fields will either have to be other object types, or resolve to some concrete data. This concrete data is represented by Scalar types. GraphQL comes with its own default set of Scalar types, but different implementations can define their own.",source:"@site/docs/reference/openreader-schema/bigint-fields.md",sourceDirName:"reference/openreader-schema",slug:"/reference/openreader-schema/bigint-fields",permalink:"/docs/reference/openreader-schema/bigint-fields",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/openreader-schema/bigint-fields.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Annotations (Directives)",permalink:"/docs/reference/openreader-schema/annotations-directives"},next:{title:"Bytes fields",permalink:"/docs/reference/openreader-schema/bytes-fields"}},p={},d=[],u={toc:d};function f(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"bigint-fields"},"BigInt fields"),(0,i.kt)("p",null,"GraphQL objects types have names and fields, but at the end of the day, these fields will either have to be other object types, or resolve to some concrete data. This concrete data is represented by ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#scalar-types"},"Scalar types"),". GraphQL comes with its own default set of Scalar types, but different implementations can define their own."),(0,i.kt)("p",null,"As part of OpenReader, we have developed the ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," Scalar type. This field allows storing much larger numbers than the commonly used ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,i.kt)("p",null,"Typical ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," fields are 4 bytes (32 bit) signed integers, which are able to represent numbers between -2147483648 and +2147483648. The ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," scalar type defined in a schema will be mapped to the ",(0,i.kt)("inlineCode",{parentName:"p"},"numeric")," field when creating the SQL table and this field is able to accommodate up to 131072 digits."),(0,i.kt)("p",null,"A schema defined as such:"),(0,i.kt)("p",null,'{% code title="schema.graphql" %}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'type Account @entity {\n  "Account address"\n  id: ID!\n  balance: BigInt!\n  historicalBalances: [HistoricalBalance!] @derivedFrom(field: "account")\n}\n\ntype HistoricalBalance @entity {\n  id: ID!\n  account: Account!\n  balance: BigInt!\n  date: DateTime!\n}\n\n')),(0,i.kt)("p",null,"{% endcode %}"),(0,i.kt)("p",null,"Will result in these tables being created:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create table account (id text primary key, balance numeric)`,\ncreate table historical_balance (id text primary key, account_id text references account(id), balance numeric, date timestamp)\n")),(0,i.kt)("p",null,"And both ",(0,i.kt)("inlineCode",{parentName:"p"},"balance")," fields will be able to store numbers like ",(0,i.kt)("inlineCode",{parentName:"p"},"2000000000000000000000000000000000000")," and much larger."))}f.isMDXComponent=!0}}]);