"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[1882],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},57732:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return d}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),o=["components"],c={},s="DateTime fields",l={unversionedId:"reference/openreader-schema/datetime-fields",id:"reference/openreader-schema/datetime-fields",title:"DateTime fields",description:"GraphQL objects types have names and fields, but at the end of the day, these fields will either have to be other object types, or resolve to some concrete data. This concrete data is represented by Scalar types. GraphQL comes with its own default set of Scalar types, but different implementations can define their own.",source:"@site/docs/reference/openreader-schema/datetime-fields.md",sourceDirName:"reference/openreader-schema",slug:"/reference/openreader-schema/datetime-fields",permalink:"/docs/reference/openreader-schema/datetime-fields",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/openreader-schema/datetime-fields.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bytes fields",permalink:"/docs/reference/openreader-schema/bytes-fields"},next:{title:"Entity Relations",permalink:"/docs/reference/openreader-schema/entity-relations"}},p={},d=[],u={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"datetime-fields"},"DateTime fields"),(0,i.kt)("p",null,"GraphQL objects types have names and fields, but at the end of the day, these fields will either have to be other object types, or resolve to some concrete data. This concrete data is represented by ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#scalar-types"},"Scalar types"),". GraphQL comes with its own default set of Scalar types, but different implementations can define their own."),(0,i.kt)("p",null,"Datetime variables and formats are quite common across various programming languages and databases. Our custom GraphQL implementation provides it via the ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime")," field, which is a date-time string in simplified extended ISO 8601 format: ",(0,i.kt)("inlineCode",{parentName:"p"},"YYYY-MM-DDTHH:mm:ss.sssZ")),(0,i.kt)("p",null,"We can reuse the basic example of ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"HistoricalBalance")," entities to show the usage of this field, because ",(0,i.kt)("inlineCode",{parentName:"p"},"HistoricalBalance")," has a ",(0,i.kt)("inlineCode",{parentName:"p"},"date")," field, which is a ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime")," Scalar."),(0,i.kt)("p",null,'{% code title="schema.graphql" %}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'type Account @entity {\n  "Account address"\n  id: ID!\n  balance: BigInt!\n  historicalBalances: [HistoricalBalance!] @derivedFrom(field: "account")\n}\n\ntype HistoricalBalance @entity {\n  id: ID!\n  account: Account!\n  balance: BigInt!\n  date: DateTime!\n}\n\n')),(0,i.kt)("p",null,"{% endcode %}"),(0,i.kt)("p",null,"And this will translate to this table being created for ",(0,i.kt)("inlineCode",{parentName:"p"},"HistoricalBalance")," entity:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create table historical_balance (id text primary key, account_id text references account(id), balance numeric, date timestamp)\n")),(0,i.kt)("p",null,"With the ",(0,i.kt)("inlineCode",{parentName:"p"},"date")," field being a ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),"."))}m.isMDXComponent=!0}}]);