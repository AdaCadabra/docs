"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[1451],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),h=n,f=d["".concat(c,".").concat(h)]||d[h]||u[h]||i;return a?r.createElement(f,o(o({ref:t},p),{},{components:a})):r.createElement(f,o({ref:t},p))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var l=2;l<i;l++)o[l]=a[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},35001:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=a(87462),n=a(63366),i=(a(67294),a(3905)),o=["components"],s={description:"Explaining the main components of a Subsquid Query Node"},c="Architecture",l={unversionedId:"key-concepts/architecture",id:"key-concepts/architecture",title:"Architecture",description:"Explaining the main components of a Subsquid Query Node",source:"@site/docs/key-concepts/architecture.md",sourceDirName:"key-concepts",slug:"/key-concepts/architecture",permalink:"/docs/key-concepts/architecture",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/key-concepts/architecture.md",tags:[],version:"current",frontMatter:{description:"Explaining the main components of a Subsquid Query Node"},sidebar:"tutorialSidebar",previous:{title:"Key Concepts",permalink:"/docs/key-concepts/"},next:{title:"Processor",permalink:"/docs/key-concepts/processor"}},p={},u=[{value:"Overview",id:"overview",level:2},{value:"Archive",id:"archive",level:3},{value:"Squid",id:"squid",level:3}],d={toc:u};function h(e){var t=e.components,s=(0,n.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"architecture"},"Architecture"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Subsquid takes a multi-layered approach that separates raw data ingestion from data processing and presentation."),(0,i.kt)("p",null,"This is very useful for the vast majority of developers, as it adds a layer of abstraction, taking care of data ingestion and synchronization, and exposing decoded Substrate chain entities (",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#events"},"Events")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#extrinsics"},"Extrinsics"),", as well as entire Blocks), for developers to process."),(0,i.kt)("p",null,"The Squid data pipeline consists of two core components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Archive"),": data source, can be shared by multiple query nodes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Squid"),": the data transformation part of the pipeline")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Squid and Archive are the main components",src:a(54714).Z,width:"555",height:"413"})),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/architecture#squid-archive"},"Archive")," can be thought of as a blockchain crawler, a data pipeline that systematically browses blockchains and that is operated by a decentralized network of squid archive node operators for the purpose of blockchain indexing."),(0,i.kt)("p",null,"In the context of a Squid query node, a Processor is responsible to get data from an Archive, transform it, and store it in the database."),(0,i.kt)("p",null,"The GraphQL Server is a separate web server providing a GraphQL API (more on the ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org"},"official website"),") for the entities in the data store."),(0,i.kt)("h3",{id:"archive"},"Archive"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/architecture#squid-archive"},"Archives")," should not be confused with ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.polkadot.network/docs/maintain-sync#types-of-nodes"},"Archive nodes"),", although the concept is vaguely similar, since both preserve the full blockchain history, without any pruning. The difference is that our Archives are special services, with specific endpoints, tailored for data retrieval."),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/architecture#squid-archive"},"Archive")," is responsible for continuously ingesting raw data from the blockchain, process blocks, and save them in a database, along with ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#events"},"Events")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#extrinsics"},"Extrinsics"),", for easier access through GraphQL APIs. Its main purpose is to provide a service, to be a high-performance, higher level data source for Squid(s)."),(0,i.kt)("p",null,"An Archive includes the following components and services:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Substrate archive"),(0,i.kt)("li",{parentName:"ul"},"Postgres database"),(0,i.kt)("li",{parentName:"ul"},"Redis data storage"),(0,i.kt)("li",{parentName:"ul"},"Status service"),(0,i.kt)("li",{parentName:"ul"},"GraphQL Gateway")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Archive components diagram",src:a(57703).Z,width:"620",height:"387"})),(0,i.kt)("p",null,"Ultimately, the Substrate Archive extracts block information, ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#events"},"Events"),", and ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/substrate#extrinsics"},"Extrinsics"),", then writes them to a Postgres database, while the status updates are saved in a Redis key-value database. Archived data is available for clients' queries, thanks to a GraphQL server running as part of every Squid Archive node."),(0,i.kt)("p",null,"An Archive can be shared by multiple Squids, which means it is possible to segment how data is presented, based on the user's needs, without having to replicate the data source."),(0,i.kt)("p",null,"To launch your own Archive for a particular Blockchain, head over to ",(0,i.kt)("a",{parentName:"p",href:"/docs/recipes/how-to-launch-a-squid-archive"},"our dedicated page")," on the topic."),(0,i.kt)("h3",{id:"squid"},"Squid"),(0,i.kt)("p",null,"A Squid is a pipeline for transforming and presenting Substrate blockchain data. It consists of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Processor"),": each node has one processor but can have multiple if connected to multiple chains"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Database"),": a PostgreSQL database where processed data is stored"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"GraphQL Server"),": every query node comes with a gateway to present processed data")),(0,i.kt)("p",null,"A Squid replaces direct gRPC node access with more performant API calls to Archive gateways, allowing bandwidth reduction and quick synchronization of the API with the historical on-chain data. It can be run locally, on a server, or deployed to the Cloud using ",(0,i.kt)("a",{parentName:"p",href:"/docs/tutorial/deploy-your-squid"},"our SaaS solution"),"."),(0,i.kt)("p",null,"Thanks to the Subsquid framework, it is possible to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"define the ",(0,i.kt)("a",{parentName:"li",href:"/docs/recipes/running-a-squid/define-a-squid-schema"},"database schema"),", ",(0,i.kt)("a",{parentName:"li",href:"/docs/recipes/running-a-squid/generate-typescript-definitions"},"data type, and entity definitions")),(0,i.kt)("li",{parentName:"ul"},"transform and store chain data efficiently"),(0,i.kt)("li",{parentName:"ul"},"present it thanks to the included GraphQL server")),(0,i.kt)("p",null,"Subsquid provides developers with a high-level GraphQL-like schema and codegen tools to model blockchain data with Entities. One of the advantages, here, is the removal of boilerplate code to unbox. A more significant advantage is certainly the elimination of incorrect data types due to wrong decoding and missing parameters."),(0,i.kt)("p",null,"Even more importantly, when handling unstructured data from events, the data format may change from one block to the next, due to runtime upgrades. Without type safety and automation guaranteed by ",(0,i.kt)("a",{parentName:"p",href:"/docs/key-concepts/typegen"},"typegen"),", managing these alterations would be a nightmare."),(0,i.kt)("p",null,"The Processor extracts data from an Archive Endpoint and does Transform-Load operations, saving it to the database. The transform-load logic is fully custom and defined by the developer."),(0,i.kt)("p",null,"Once the schema and the mappings are set up, and the node is launched, it will start the continuous scan of the blockchain, processing the events through the Event handlers and updating the entities in the database."),(0,i.kt)("p",null,"The API requests are resolved by the GraphQL server by sourcing data from the Processor database. ",(0,i.kt)("a",{parentName:"p",href:"https://www.opencrud.org"},"OpenCRUD")," filtering, entity relations, pagination, and text queries are supported out-of-the-box by the API."))}h.isMDXComponent=!0},54714:function(e,t,a){t.Z=a.p+"assets/images/Squid_Architecture-4db2e48d5427aee2e7b5dea483e5fb73.png"},57703:function(e,t,a){t.Z=a.p+"assets/images/Squid_Archive-4355849bf0b12ead62442b2d64adfc1d.png"}}]);