"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[2489],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||r;return n?i.createElement(h,o(o({ref:t},d),{},{components:n})):i.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},61959:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),o=["components"],l={},s="Annotations (Directives)",c={unversionedId:"reference/openreader-schema/annotations-directives",id:"reference/openreader-schema/annotations-directives",title:"Annotations (Directives)",description:"Directives are a native feature of GraphQL, whose purpose is to affect execution of the query in any way the server desires when attached to fields. They are also commonly known as Annotations in other languages such as Java.",source:"@site/docs/reference/openreader-schema/annotations-directives.md",sourceDirName:"reference/openreader-schema",slug:"/reference/openreader-schema/annotations-directives",permalink:"/docs/reference/openreader-schema/annotations-directives",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/openreader-schema/annotations-directives.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"OpenReader Schema",permalink:"/docs/reference/openreader-schema/"},next:{title:"BigInt fields",permalink:"/docs/reference/openreader-schema/bigint-fields"}},d={},p=[{value:"<code>@entity</code>",id:"entity",level:2},{value:"<code>@derivedFrom</code>",id:"derivedfrom",level:2},{value:"<code>@unique</code>",id:"unique",level:2},{value:"<code>@index</code>",id:"index",level:2}],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"annotations-directives"},"Annotations (Directives)"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#directives"},"Directives")," are a native feature of GraphQL, whose purpose is to affect execution of the query in any way the server desires when attached to fields. They are also commonly known as Annotations in other languages such as Java."),(0,r.kt)("p",null,"The two directives included in the core GraphQL specification are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@include(if: Boolean)")," Only include this field in the result if the argument is ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@skip(if: Boolean)")," Skip this field if the argument is ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),".")),(0,r.kt)("p",null,"Our spec-compliant GraphQL server implementation called OpenReader allows the definition of a few more, listed below:"),(0,r.kt)("h2",{id:"entity"},(0,r.kt)("inlineCode",{parentName:"h2"},"@entity")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@entity")," this is attached to a ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," and it signifies it should be persisted in the database with a corresponding table. The ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),"(s) defined without this directive will be considered objects, for more on this see the ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/openreader-schema/json-fields"},"JSON field reference"),"."),(0,r.kt)("p",null,"A sample schema using this would be the following:"),(0,r.kt)("p",null,'{% code title="schema.graphql" %}'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type WorkReport @entity {\n  id: ID! #event id\n  account: Account!\n  addedFiles: [[String]]\n  deletedFiles: [[String]]\n  extrinisicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n\ntype JoinGroup @entity {\n  id: ID!\n  member: Account!\n  owner: String!\n  extrinisicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n\ntype StorageOrder @entity {\n  id: ID!\n  account: Account!\n  fileCid: String!\n  extrinisicId: String\n  createdAt: DateTime!\n  blockHash: String!\n  blockNum: Int!\n}\n\ntype Account @entity {\n  id: ID! #Account address\n  workReports: [WorkReport] @derivedFrom(field: "account")\n  joinGroups: [JoinGroup] @derivedFrom(field: "member")\n  storageOrders: [StorageOrder] @derivedFrom (field: "account")\n}\n')),(0,r.kt)("p",null,"{% endcode %}"),(0,r.kt)("p",null,"All four types defined here will have a corresponding table in the database."),(0,r.kt)("p",null,"The last type defined in this schema, ",(0,r.kt)("inlineCode",{parentName:"p"},"Account"),", uses another Directive, explained in detail below."),(0,r.kt)("h2",{id:"derivedfrom"},(0,r.kt)("inlineCode",{parentName:"h2"},"@derivedFrom")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@derivedFrom")," directive is used in a relation between two ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),"s to state that a field should not be persisted in the database."),(0,r.kt)("p",null,"This directive should be attached to a type's field, defining a relation with another type. Furthermore, the directive accepts an argument ",(0,r.kt)("inlineCode",{parentName:"p"},"field"),", which is used to specify the field in the related Entity to derive from."),(0,r.kt)("p",null,"This way, a two-way relationship between the two types is established through that specific field. Let's look at a simple schema:"),(0,r.kt)("p",null,'{% code title="schema.graphql" %}'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Account @entity {\n  "Account address"\n  id: ID!\n  balance: BigInt!\n  historicalBalances: [HistoricalBalance!] @derivedFrom(field: "account")\n}\n\ntype HistoricalBalance @entity {\n  id: ID!\n  account: Account!\n  balance: BigInt!\n  date: DateTime!\n}\n\n')),(0,r.kt)("p",null,"{% endcode %}"),(0,r.kt)("p",null,"This schema defines two entities: ",(0,r.kt)("inlineCode",{parentName:"p"},"Account")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"HistoricalBalance"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"historicalBalances")," field of ",(0,r.kt)("inlineCode",{parentName:"p"},"Account")," creates a one-to-many relationship between the two Entities."),(0,r.kt)("p",null,"What's important to note is that because the ",(0,r.kt)("inlineCode",{parentName:"p"},"@derivedFrom")," directive is attached to ",(0,r.kt)("inlineCode",{parentName:"p"},"historicalBalances"),", this field is not going to be persisted in the database, rather, as the directive name suggests, it will be derived from the relationship. The table for ",(0,r.kt)("inlineCode",{parentName:"p"},"Account")," will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table account (id text primary key, balance numeric)\n")),(0,r.kt)("p",null,"On the contrary, the table for ",(0,r.kt)("inlineCode",{parentName:"p"},"HistoricalBalance")," will have a special mention in the ",(0,r.kt)("inlineCode",{parentName:"p"},"account_id")," field, referencing the table for ",(0,r.kt)("inlineCode",{parentName:"p"},"Account")," entity:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table historical_balance (id text primary key, account_id text references account(id), balance numeric)\n")),(0,r.kt)("h2",{id:"unique"},(0,r.kt)("inlineCode",{parentName:"h2"},"@unique")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@unique")," directive is attached to a field and simply enough, means that such a field should be unique for this type. A sample schema using it looks like this:"),(0,r.kt)("p",null,'{% code title="schema.graphql" %}'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Issue @entity {\n    id: ID!\n    payment: IssuePayment @derivedFrom(field: "issue")\n    cancellation: IssueCancellation @derivedFrom(field: "issue")\n}\n\ntype IssuePayment @entity {\n    id: ID!\n    issue: Issue! @unique\n    amount: Int!\n}\n\ntype IssueCancellation @entity {\n    id: ID!\n    issue: Issue! @unique\n    height: Int!\n}\n')),(0,r.kt)("p",null,"{% endcode %}"),(0,r.kt)("p",null,"This will be reflected in the automatically created tables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table issue (id text primary key)\ncreate table issue_payment (id text primary key, issue_id text not null unique, amount numeric)\ncreate table issue_cancellation (id text primary key, issue_id text not null unique, height int)\n")),(0,r.kt)("h2",{id:"index"},(0,r.kt)("inlineCode",{parentName:"h2"},"@index")),(0,r.kt)("p",null,"This particular annotation is responsible for the creation of indexes on specified fields when creating the database tables, and as such it is quite important to master it, in order to obtain the maximum performance out of your Squid API."),(0,r.kt)("p",null,"Let's take a look at a very simple schema making use of this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'" All transfers "\ntype Transfer @entity @index(fields: ["block", "extrinsicId"]) {\n  from: Bytes! @index\n  to: Bytes!\n  fromAccount: Account\n  toAccount: Account\n  value: BigInt!\n  block: Int!\n  tip: BigInt!\n  timestamp: BigInt!\n  insertedAt: DateTime!\n  extrinsicId: String\n}\n\ntype Account @entity {\n  "Account address"\n  id: ID!\n  balance: BigInt!\n  incomingTx: [Transfer!] @derivedFrom(field: "toAccount")\n  outgoingTx: [Transfer!] @derivedFrom(field: "fromAccount")\n}\n\n')),(0,r.kt)("p",null,"You could quickly note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"@index")," directive has been used both on a single field (",(0,r.kt)("inlineCode",{parentName:"p"},"from"),") and on an entire entity (",(0,r.kt)("inlineCode",{parentName:"p"},"Transfer"),"), specifying which fields will serve as indices of uniqueness for the entity itself (in this case, both ",(0,r.kt)("inlineCode",{parentName:"p"},"blocks")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extrinsicId"),")."),(0,r.kt)("p",null,"As mentioned before, this will make sure that an index on the ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Transfer")," table will be created, but will also create a joint index out of the ",(0,r.kt)("inlineCode",{parentName:"p"},"block")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"extrinsicId")," fields."),(0,r.kt)("p",null,"On a final note, it is worth noticing that ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Foreign_key"},"Foreign Keys")," are indexed by default. So in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"fromAccount")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"toAccount")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Transfer")," table will also be indexed."))}m.isMDXComponent=!0}}]);