"use strict";(self.webpackChunksubsquid_docs=self.webpackChunksubsquid_docs||[]).push([[1069],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return y}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(n),y=i,f=u["".concat(c,".").concat(y)]||u[y]||d[y]||r;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},40064:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return y},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return d}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),s=["components"],o={},c="Store interface",l={unversionedId:"reference/store-interface",id:"reference/store-interface",title:"Store interface",description:"When working with Subsquid SDK and building on the SubstrateProcessor, the Store is a very important concept one. As briefly explained in the Key Concept page dedicated to the Processor, it serves as an interface for the data-persistence layer, often represented by a database.",source:"@site/docs/reference/store-interface.md",sourceDirName:"reference",slug:"/reference/store-interface",permalink:"/docs/reference/store-interface",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/store-interface.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Storage calls",permalink:"/docs/reference/storage-calls"},next:{title:"Substrate Processor",permalink:"/docs/reference/substrate-processor"}},p={},d=[{value:"Finding objects",id:"finding-objects",level:2},{value:"Persisting objects",id:"persisting-objects",level:2},{value:"Ad-hoc queries",id:"ad-hoc-queries",level:2},{value:"Bulk updates",id:"bulk-updates",level:3}],u={toc:d};function y(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"store-interface"},"Store interface"),(0,r.kt)("p",null,"When working with Subsquid SDK and building on the ",(0,r.kt)("inlineCode",{parentName:"p"},"SubstrateProcessor"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," is a very important concept one. As briefly explained in the Key Concept page dedicated to the Processor, it serves as an interface for the data-persistence layer, often represented by a database."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," interface we implemented is an extension of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityManager")," from the ",(0,r.kt)("a",{parentName:"p",href:"https://typeorm.io/#/"},"TypeORM")," library. It is a dependency of the project, so it should be installed with the rest of them, but to manually install it, simply run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npm install typeorm\n")),(0,r.kt)("p",null,"In the context of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SubstrateProcessor"),", there are a few noteworthy functions exposed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Store"),", which we'll focus on during this guide."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," interface is usually passed as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventHandlerContext"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtrinsicHandlerContext")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockHandlerContext"),", depending on the handler on the receiving end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface EventHandlerContext {\n    store: Store\n    block: SubstrateBlock\n    event: SubstrateEvent\n    extrinsic?: SubstrateExtrinsic\n    /**\n     * Not yet public description of chain metadata\n     * @internal\n     */\n    _chain: Chain\n}\n")),(0,r.kt)("p",null,"So when defining an Event Handler, it's possible to use all the functions exposed by the interface. Here is a summary of the most important ones:"),(0,r.kt)("h2",{id:"finding-objects"},"Finding objects"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," interface exposes various methods for finding objects, here's a few, defined directly as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityManager")," parent interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export declare class EntityManager {\n     // ...\n     \n     // Finds entities that match given options.\n     find<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<Entity[]>;\n     // Finds entities that match given conditions.\n     find<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<Entity[]>;\n}\n\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"options")," can be an object containing options arguments like: ",(0,r.kt)("inlineCode",{parentName:"p"},"select"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"where"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"relations"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"join"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"order"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"cache"),". An example of usage might be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"let scalar = await em.find(Scalar, {\n    order: {\n        id: 'ASC'\n    }\n})\n\n")),(0,r.kt)("p",null,"Other methods include:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export declare class EntityManager {\n     // ...\n     \n     // Finds entities with ids.\n     // Optionally find options can be applied.\n     findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], options?: FindManyOptions<Entity>): Promise<Entity[]>;\n     // Finds entities with ids.\n     // Optionally conditions can be applied.\n     findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], conditions?: FindConditions<Entity>): Promise<Entity[]>;\n}\n\n")),(0,r.kt)("p",null,"And:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export declare class EntityManager {\n    // ...\n    // Finds first entity that matches given find options.\n    findOne<Entity>(entityClass: EntityTarget<Entity>, id?: string | number | Date | ObjectID, options?: FindOneOptions<Entity>): Promise<Entity | undefined>;\n\n    // Finds first entity that matches given find options.\n    findOne<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<Entity | undefined>;\n\n    // Finds first entity that matches given conditions.\n    findOne<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>, options?: FindOneOptions<Entity>): Promise<Entity | undefined>;\n}\n\n")),(0,r.kt)("h2",{id:"persisting-objects"},"Persisting objects"),(0,r.kt)("p",null,"In order to persist objects in the database, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," interface has the ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," method, which has various signatures available:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export declare class EntityManager {\n\n    // ...\n    \n    // Saves all given entities in the database.\n    // If entities do not exist in the database then inserts, otherwise updates.\n    save<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    // Saves all given entities in the database.\n    // If entities do not exist in the database then inserts, otherwise updates.\n    save<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    // Saves all given entities in the database.\n    // If entities do not exist in the database then inserts, otherwise updates.\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options: SaveOptions & {\n        reload: false;\n    }): Promise<T[]>;\n\n    // Saves all given entities in the database.\n    // If entities do not exist in the database then inserts, otherwise updates.\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<(T & Entity)[]>;\n\n    // Saves a given entity in the database.\n    // If entity does not exist in the database then inserts, otherwise updates.\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options: SaveOptions & {\n        reload: false;\n    }): Promise<T>;\n\n    // Saves a given entity in the database.\n    // If entity does not exist in the database then inserts, otherwise updates.\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T & Entity>;    \n}\n")),(0,r.kt)("p",null,"A typical usage is, in the body of an Event or Extrinsic Handler function, to save an Entity in the database:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"processor.addEventHandler('balances.Transfer', async ctx => {\n    let transfer = getTransferEvent(ctx)\n    let tip = ctx.extrinsic?.tip || 0n\n    let from = ss58.codec('kusama').encode(transfer.from)\n    let to = ss58.codec('kusama').encode(transfer.to)\n\n    let fromAcc = await getOrCreate(ctx.store, Account, from)\n    fromAcc.balance = fromAcc.balance || 0n\n    fromAcc.balance -= transfer.amount\n    fromAcc.balance -= tip\n    await ctx.store.save(fromAcc)\n\n    const toAcc = await getOrCreate(ctx.store, Account, to)\n    toAcc.balance = toAcc.balance || 0n\n    toAcc.balance += transfer.amount\n    await ctx.store.save(toAcc)\n\n    await ctx.store.save(new HistoricalBalance({\n        id: ctx.event.id + '-to',\n        account: fromAcc,\n        balance: fromAcc.balance,\n        date: new Date(ctx.block.timestamp)\n    }))\n\n    await ctx.store.save(new HistoricalBalance({\n        id: ctx.event.id + '-from',\n        account: toAcc,\n        balance: toAcc.balance,\n        date: new Date(ctx.block.timestamp)\n    }))\n})\n")),(0,r.kt)("h2",{id:"ad-hoc-queries"},"Ad-hoc queries"),(0,r.kt)("p",null,"When the offered methods aren't enough, it is still possible to run ad-hoc queries through the ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," interface, thanks to the ",(0,r.kt)("inlineCode",{parentName:"p"},"query")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export declare class EntityManager {\n    // ...\n\n    // Executes raw SQL query and returns raw database results.\n    query(query: string, parameters?: any[]): Promise<any>;\n}\n\n")),(0,r.kt)("p",null,"Here are a couple of examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'processor.addEventHandler("balances.Transfer", async (ctx) => {\n\n  let schema = `"${processor}_status"`\n  await ctx.store.query(`CREATE SCHEMA IF NOT EXISTS ${schema}`)\n  await ctx.store.query(`\n    CREATE TABLE IF NOT EXISTS ${schema}."status" (\n      id int primary key,\n      height int not null\n    )\n  `)\n  await ctx.store.query(`INSERT INTO ${schema}.status (id, height) VALUES (0, -1)`)\n  let height = await ctx.store.query(\'SELECT height FROM status WHERE id = 0\');\n});\n')),(0,r.kt)("h3",{id:"bulk-updates"},"Bulk updates"),(0,r.kt)("p",null,"Examples of usage of ad-hoc queries include the possibility to perform bulk-updates:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"await ctx.store.query(`UPDATE ${schema}.status SET height = $1 WHERE height < $1`, [blockNumber]\n")))}y.isMDXComponent=!0}}]);